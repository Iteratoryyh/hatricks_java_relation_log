**JVM-学习郑宇迪教程-有感**  
---
2019年2月1日14:05:29

## JVM如何执行方法调用
### 从两个方面来看:
- **.java文件,也就是编译器来看**
- **.class文件,也就是运行时期来看**

**编译期:**
即我们自己写代码的时期,也就是我们有的工具可能会写一行代码就编译器;
从编译器的角度来看,一个类中是不允许有方法名称相同,并且形参完全一致,包括顺序完全一致,因为这会导致虚拟机不知道当前要调用的是那个方法;
(但是可以绕过编译器,将编译器编译成class文件来手动更改一下,我们虚拟机是可以接受形参包括方法名称完全相同,只要返回值不相同)的这种情况


**运行期:**
也就是我们需要动态确定,运行时需要调用的方法,也就是虚方法表,其实我们在重写了父类的方法之后,使用父类的引用在调用子类对象的时候,
在具体引用的时候,如果当前是(invokestatic,invokespecial)的时候,当前的引用代表就是需要标示方法的具体内存地址,在当前是invokevirtual
和invokeinterface的时候,虚拟机需要在执行的过程中,根据调用者的动态类型,来确定具体的目标方法;

**其实invokevirtual的时候,是根据实际类型是一个方法表的索引,然后根据实际类型对象头中的kclass找到实际类型的地址:classloader+包名+类名的内存地址,拿到实际调用的方法,入栈**
**然后invokeinterface的时候,是拿到当前实际类型,然后到方法表中去搜索当前方法名称以及参数名称还有返回值匹配的方法,进行调用入栈**

在进行JIT即时编译的时候,会有方法内联和内联缓存两种内部调优方式;JavaJIT会采用单态内联缓存来进行优化,就是说第一次访问会将实际类型缓存起来,
然后再下一次访问的时候,动态类型和缓存类型不匹配的情况下,就会回退到查找方法表(即使是这样子,其实影响也并不是很大,只是多了2次内存地址访问而已),
跟使用设计模式良好的扩展性比起来,其实无伤大雅.

## JVM的异常处理机制:

- 抛异常的时候,我们要从当前栈帧中,拿到方法的执行信息,以及方法报错的字节码行号,还有源代码的行号,以及文件名称,所以在构建异常栈帧的时候,
是一个比较费时的操作.

- 在catch操作中相当于使用了责任链模式,每一次自己处理不了的时候,都会传递给下一个,finally中的代码相当于在所有的正常出口以及异常出口都
进行了类似于代码复制的操作,来保证finally中的代码能够进行正常的执行
```
```  
